# -*- coding: utf-8 -*-
"""dijkstra_search_it3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DDUyozjwiiznNsXQgA48dlDUXJe4IKBI

Importing libraries
"""

import numpy as np
import sympy as sp
import os
from queue import PriorityQueue
import matplotlib.pyplot as mp
import pygame
import cv2
import time

"""Note: workspace is a rectangle of width b = 400 mm and height h = 250 mm



Creating the workspace with all default values as once
"""

#node size ratio (unit/node)
def map():
    global x_size, y_size, map_def, Rat
    Rat = 1 #unit per node
    x_size = int(400/Rat)
    y_size = int(250/Rat)
    map_def = np.zeros(x_size*y_size)
    map_def = np.reshape(map_def,(y_size,x_size))
    map_def[:,:] = -2

"""Defining obstacle space

Circle
"""

#x is column and y is row
def circle_obs():
    global x_c, y_c, x_nc, y_nc, map_obs1, obs_list
    x_c = []
    y_c = []
    #without clearance
    x_nc = []
    y_nc = []
    y_centre = int((249 - 65)/Rat)
    x_centre = int((399 - 100)/Rat)
    radius_c = int(45/Rat)
    radius = int(40/Rat)
    map_obs1 = np.copy(map_def)
    for x in range(int(250/Rat),int(350/Rat)):
        for y in range(int(125/Rat), int(235/Rat)):
            if (np.sqrt((x-x_centre)**2 + (y-y_centre)**2)) < radius_c:
                map_obs1[y, x] = -1
                x_c.append(x)
                y_c.append(y)
            if (np.sqrt((x-x_centre)**2 + (y-y_centre)**2)) < radius:
                x_nc.append(x)
                y_nc.append(y)
                obs_list.append([x,y])

"""Triangles"""

def triang_obs():
    global x_t1, y_t1, x_t1_nc, y_t1_nc, map_obs2, x_t2_nc, y_t2_nc, x_t2, y_t2, obs_list
    y1 = sp.symbols('y1')
    x1 = sp.symbols('x1')
    y2 = sp.symbols('y2')
    x2 = sp.symbols('x2')
    y3 = sp.symbols('y3')
    x3 = sp.symbols('x3')
    y4 = sp.symbols('y4')
    x4 = sp.symbols('x4')
    y5 = sp.symbols('y5')
    x5 = sp.symbols('x5')

    e1 = y1 - (-5/54)*x1 - 187.87
    e2 = y2 - (-85/69)*x2 - (15681/69) +8 #222.7
    e2_nc = y2 - (-85/69)*x2 - 15681/69 #15681/69
    e3 = y3 - (-16/5)*x3 - (2169/5) -15 #543.25
    e3_nc = y3 - (-16/5)*x3 - 2169/5
    e4 = y4 - (6/7)*x4 - (779/7) + 5
    e4_nc = y4 - (6/7)*x4 - 779/7
    e5 = y5 - (25/79)*x5 - (13661/79) -5
    e5_nc = y5 - (25/79)*x5 - 13661/79
    x_t1 = []
    y_t1 = []
    x_t2 = []
    y_t2 = []
    #without clearance
    x_t1_nc = [] 
    y_t1_nc = []
    x_t2_nc = []
    y_t2_nc = []
    map_obs2 = np.copy(map_obs1)
    for x in range(int(140/Rat)):
        for y in range(int(80/Rat),int(220/Rat)):
           
            if e1.subs([(x1,x),(y1,y)])<=0 and e2.subs([(x2,x),(y2,y)])>=0 and e3.subs([(x3,x),(y3,y)])<=0 :
                map_obs2[y,x] = -1
                x_t1.append(x)
                y_t1.append(y)
           
            if e1.subs([(x1,x),(y1,y)])<=0 and e2_nc.subs([(x2,x),(y2,y)])>=0 and e3_nc.subs([(x3,x),(y3,y)])<=0 :
                x_t1_nc.append(x)
                y_t1_nc.append(y)
                obs_list.append([x,y])
            if e1.subs([(x1,x),(y1,y)])>=0 and e4.subs([(x4,x),(y4,y)])>=0 and e5.subs([(x5,x),(y5,y)])<=0:
                map_obs2[y,x] = -1
                x_t2.append(x)
                y_t2.append(y)
           
            if e1.subs([(x1,x),(y1,y)])>=0 and e4_nc.subs([(x4,x),(y4,y)])>=0 and e5_nc.subs([(x5,x),(y5,y)])<=0:
                x_t2_nc.append(x)
                y_t2_nc.append(y)
                obs_list.append([x,y])

"""

Hexagon
"""

def hex_obs():
    global map_obs4, x_h, y_h, x_h_nc, y_h_nc, obs_list
    y6 = sp.symbols('y6')
    x6 = sp.symbols('x6')
    y7 = sp.symbols('y7')
    x7 = sp.symbols('x7')
    y8 = sp.symbols('y8')
    x8 = sp.symbols('x8')
    y9 = sp.symbols('y9')
    x9 = sp.symbols('x9')
    x10 = sp.symbols('x10')
    x11 = sp.symbols('x11')

    e6 = y6 - (5/8)*x6 + 71
    e6_nc = y6 - (4/7)*x6 + 380/7
    e10 = x10 - 239
    e10_nc = x10 - 234
    e7 = y7 + (5/8)*x7 - 271
    e7_nc = y7 + (4/7)*x7 - 1780/7
    e8 = y8 - (5/8)*x8 - 21
    e8_nc = y8 - (4/7)*x8 - 180/7
    e11 = x11 - 160
    e11_nc = x11 - 164
    e9 = y9 + (5/8)*x9 - 179
    e9_nc = y9 + (4/7)*x9 - 1220/7
    x_h = []
    y_h = []
    x_h_nc = []
    y_h_nc = []
    map_obs4 = np.copy(map_obs2)
    for x in range(int(150/Rat), int(250/Rat)):
        for y in range(int(50/Rat),int(155/Rat)):
            if e6.subs([(x6,x),(y6,y)])>=0 and e7.subs([(x7,x),(y7,y)])<=0 and e8.subs([(x8,x),(y8,y)])<=0 and e9.subs([(x9,x),(y9,y)])>=0 and e10.subs([(x10,x)])<=0 and e11.subs([(x11,x)])>=0:
                map_obs4[y,x] = -1
                x_h.append(x)
                y_h.append(y)
                
            if e6_nc.subs([(x6,x),(y6,y)])>=0 and e7_nc.subs([(x7,x),(y7,y)])<=0 and e8_nc.subs([(x8,x),(y8,y)])<=0 and e9_nc.subs([(x9,x),(y9,y)])>=0 and e10_nc.subs([(x10,x)])<=0 and e11_nc.subs([(x11,x)])>=0:
                x_h_nc.append(x)
                y_h_nc.append(y)
                obs_list.append([x,y])

"""The main algorithm

Data structure
"""

class Node:
    def __init__(self, node_id, node_loc, parent_id, cost):
        self.parent_id = parent_id #
        self.node_id = node_id #unique node id for each node
        self.node_loc = node_loc
        self.cost = round(cost,1)

"""Creating required list for storing node information

Initialize the goal node

Remember x is column and y is rows, a is row and b is column

2) Update the value at the matrix space to node id itself when visited

moving north

Getting the node to be explored from Open list
"""

def pop(Cl_list, Op_list, Al_list):
    dat = Op_list.get()
    Cl_list.append(All_list[dat[1]-1])
    return Al_list[dat[1]-1], dat[0]


"""Cost Dictionary"""

cost_direction = {'S': 1, 'D': 1.4}

"""Parameter update"""

def param(All_list, Open_list, map_obs4, cost_dir, c, d, node):
     id = All_list[-1].node_id + 1
     map_obs4[c,d] = id
     cost = node.cost + cost_dir #cost_dir is a dictionary
     
     parent = node.node_id
     loc = [c, d]
     All_list.append(Node(id, loc, parent, cost))
     tup_new = [cost, id]
     Open_list.put(tup_new)

"""List cost update function"""

def cost_update(nod, c ,d, All_list,  Closed_list, Open_list, map_obs4, cost_dir):
     index = int(map_obs4[c, d])
     if round((nod.cost + cost_dir),1)< round(All_list[index-1].cost,1): #since index/node_id is starting from 1
            All_list[index-1].cost = round((nod.cost + cost_dir),1)
            All_list[index-1].parent_id = nod.node_id
            for i in Closed_list:
                if i.node_id ==index:
                        i.cost = round((nod.cost + cost_dir),1)
                        i.parent_id = nod.node_id
            if Open_list.qsize() > 0:
                for j in Open_list.queue:
                    if j[1] ==index:
                            j[0] = round((nod.cost + cost_dir),1)

"""Check if goal function"""

def check_if_goal(goal_loc, A_list, go_cost):
    if goal_loc==A_list[-1].node_loc:
        go_cost = A_list[-1].cost #updates the goal cost
        print('goal cost is', go_cost)
        return go_cost
    else:
        return None


def move_north(node, All_list, Open_list, go_co): #change the list names
    a,b = 0,0
    a, b = node.node_loc
    if a < 249:
        c = a+1
        d = b
        if map_obs4[c,d]== -2:
        #creating new node with new parameters
            param(All_list, Open_list, map_obs4, cost_direction['S'], c, d, node)            
            return check_if_goal(goal_location, All_list, go_co)
        
        elif map_obs4[c,d]==-1:
            return None
        
        else:
            cost_update(node, c ,d, All_list,  Closed_list, Open_list, map_obs4, cost_direction['S'])  
            return None

"""moving east"""

def move_east(node, All_list, Open_list, go_co):
    a,b = 0,0
    a, b = node.node_loc
    if b < 399:
        c = a
        d = b+1
        if map_obs4[c, d]== -2:

            param(All_list, Open_list, map_obs4, cost_direction['S'], c, d, node)            
            return check_if_goal(goal_location, All_list, go_co)
        
        elif map_obs4[c,d]==-1:
            return None
        
        else:
            cost_update(node, c ,d, All_list,  Closed_list, Open_list, map_obs4, cost_direction['S'])
            return None

"""moving west"""

def move_west(node, All_list, Open_list, go_co):
    a,b = 0,0
    a, b = node.node_loc
    if b > 0:
        c = a
        d = b-1
        if map_obs4[c,d]== -2:
            param(All_list, Open_list, map_obs4, cost_direction['S'], c, d, node)            
            return check_if_goal(goal_location, All_list, go_co) 

        elif map_obs4[c,d]==-1:
            return None
        
        else:
            cost_update(node, c ,d, All_list,  Closed_list, Open_list, map_obs4, cost_direction['S'])
            return None

"""moving south"""

def move_south(node, All_list, Open_list, go_co):
    a,b = 0,0
    a, b = node.node_loc
    if a > 0:
        c = a-1
        d = b
        if map_obs4[c,d]== -2:
            param(All_list, Open_list, map_obs4, cost_direction['S'], c, d, node)            
            return check_if_goal(goal_location, All_list, go_co)
        
        elif map_obs4[c,d]==-1:
            return None
        
        else:
            cost_update(node, c ,d, All_list,  Closed_list, Open_list, map_obs4, cost_direction['S'])
            return None

"""Moving north east"""

def move_north_east(node, All_list, Open_list, go_co):
    a,b = 0,0
    a, b = node.node_loc
    if a < 249 and b <399:
        c = a + 1
        d = b + 1
        if map_obs4[c,d]== -2:
            param(All_list, Open_list, map_obs4, cost_direction['D'],c, d, node)            
            return check_if_goal(goal_location, All_list, go_co)
        
        elif map_obs4[c,d]==-1:
            return None
        
        else:
            cost_update(node, c ,d, All_list,  Closed_list, Open_list, map_obs4, cost_direction['D'])
            return None

"""Northwest"""

def move_north_west(node, All_list, Open_list, go_co):
    a,b = 0,0
    a, b = node.node_loc
    if a < 249 and b >0:
        c = a + 1
        d = b - 1
        if map_obs4[c,d]== -2:
            param(All_list, Open_list, map_obs4, cost_direction['D'],c, d, node)
            return check_if_goal(goal_location, All_list, go_co)
        
        elif map_obs4[c,d]==-1:
            return None
        
        else:
            cost_update(node, c ,d, All_list,  Closed_list, Open_list, map_obs4, cost_direction['D'])
            return None

"""Southwest"""

def move_south_west(node, All_list, Open_list, go_co):
    a,b = 0,0
    a, b = node.node_loc
    if a > 0 and b >0:
        c = a - 1
        d = b - 1
        if map_obs4[c,d]== -2:
            param(All_list, Open_list, map_obs4, cost_direction['D'],c, d, node)
            return check_if_goal(goal_location, All_list, go_co)
        
        elif map_obs4[c,d]==-1:
            return None
        
        else:
            cost_update(node, c ,d, All_list,  Closed_list, Open_list, map_obs4, cost_direction['D'])
            return None

"""Southeast"""

def move_south_east(node, All_list, Open_list, go_co):
    a,b = 0,0
    a, b = node.node_loc
    if a >0 and b <399:
        c = a - 1
        d = b + 1
        if map_obs4[c,d]== -2:
            param(All_list, Open_list, map_obs4, cost_direction['D'], c, d, node)
            return check_if_goal(goal_location, All_list, go_co)
        
        elif map_obs4[c,d]==-1:
            return None
        
        else:
            cost_update(node, c ,d, All_list,  Closed_list, Open_list, map_obs4, cost_direction['D'])
            return None

def movement(node, All_list, Open_list, go_co):
    go_co = None
    if (move_north(node, All_list, Open_list, go_co))!=None:
        go_co = All_list[-1].cost
    if (move_west(node, All_list, Open_list, go_co))!=None:
        go_co = All_list[-1].cost
    if (move_south(node, All_list, Open_list, go_co))!=None:
        go_co = All_list[-1].cost
    if (move_east(node, All_list, Open_list, go_co))!=None:
        go_co = All_list[-1].cost
    if (move_north_east(node, All_list, Open_list, go_co))!=None:
        go_co = All_list[-1].cost
    if (move_north_west(node, All_list, Open_list, go_co))!=None:
        go_co = All_list[-1].cost
    if (move_south_east(node, All_list, Open_list, go_co))!=None:
        go_co = All_list[-1].cost
    if (move_south_west(node, All_list, Open_list, go_co))!=None:
        go_co = All_list[-1].cost           
    return go_co

def backtrack(A_list, x, y):
    ind = int(map_obs4[goal_location[0], goal_location[1]])
    x.append(A_list[ind-1].node_loc[0])
    y.append(A_list[ind-1].node_loc[1])
    id = A_list[ind-1].parent_id
    while(id>0):
        x.append(A_list[id-1].node_loc[0])
        y.append(A_list[id-1].node_loc[1])
        id = A_list[id - 1].parent_id

def initial():
    global All_list, Closed_list, goal_location, Open_list, obs_list
    obs_list = []
    All_list = []
    Closed_list = []
    first_node_id = 1
    start_cords_x = int(input("please enter the starting x coordinate from 1-400: "))
    start_cords_y = int(input("please enter the starting x coordinate from 1-250: "))
    if start_cords_x<1 or start_cords_x>400 or start_cords_y<1 or start_cords_y>400:
        print("-----RERUN THE PROGRAM AND PUT VALUES FOR X-->(1-400) and Y-->(1-250) only-----")
        exit(0)
    else:
        node_loc = [start_cords_y-1, start_cords_x-1]
    goal_cords_x = int(input("please enter the goal x coordinate from 1-400: "))
    goal_cords_y = int(input("please enter the goal y coordinate from 1-250: "))
    if goal_cords_x<1 or goal_cords_x>400 or goal_cords_y<1 or goal_cords_y>250 or (goal_cords_x==start_cords_x and goal_cords_y==start_cords_y):
        print("Either goal out of 2D space or goal and the start is same.----TRY AGAIN----")
        exit(0)
    else:
        goal_location = [goal_cords_y-1, goal_cords_x-1]
    print('defining the provided obstacle space, phew its a big place')
    map()
    circle_obs()
    triang_obs()
    hex_obs()
    print('obstacle space defined')
    if map_obs4[start_cords_y-1, start_cords_x-1]==-1 or map_obs4[goal_cords_y-1, goal_cords_x-1]==-1:
        print("------------------start or goal node in obstacle space-------RERUN THE CODE")
        exit(0)
    else:
        map_obs4[start_cords_y-1, start_cords_x-1] = first_node_id
    first_parent_id = 0
    first_cost = 0
    All_list.append(Node(first_node_id, node_loc, first_parent_id, first_cost))
    tup = [first_cost, first_node_id] # just the cost and node id, access the node using all visited and node id
    Open_list = PriorityQueue()
    Open_list.put(tup)

"""Take the input from user"""

initial()
print('have patience now, searching...')
goal_cost = 100000
while(1):
    if (Open_list.qsize()>0):
        node, PQ_cost = pop(Closed_list, Open_list, All_list)
        
        if round(goal_cost,1)>round(PQ_cost,1):
            check = movement(node, All_list, Open_list, goal_cost)
            if(check!=None):
                # print('mila na')
                goal_cost = All_list[int(map_obs4[goal_location[0],goal_location[1]]-1)].cost

                print('goal cost is', goal_cost)
        else:
            print('cost exceeded')
            break
    
    else:
        print('open list empty')
        break

"""Backtracking"""

if (map_obs4[goal_location[0], goal_location[1]]!=-1 and map_obs4[goal_location[0], goal_location[1]]!=-2 ):
    x_a = []
    y_a = []
    backtrack(All_list, x_a, y_a)    
else:
    print('cannot be back tracked')



"""Priority queueu has a problem with objects (try any other method): check once

Put animation here
"""

canvas = np.zeros((250,400,3),np.uint8)


for c in obs_list: #change the name of the variable l
    x = c[1]
    y = c[0]
    canvas[(x,y)]=[0,255,255] #assigning a yellow coloured pixel
canvas = np.flipud(canvas)
canvas_for_backtrack = canvas.copy()
canvas_for_visited = canvas.copy()
canvas_for_visited = cv2.resize(canvas_for_visited,(1200,750))
# #showing the obstacle map
cv2.imshow('canvas',canvas)
cv2.waitKey(0)
cv2.destroyAllWindows()

pygame.init()

display_width = 400
display_height = 250

gameDisplay = pygame.display.set_mode((display_width,display_height),0, 100)
pygame.display.set_caption('Visited Nodes- Animation')

black = (0,0,0)
white = (0,255,255)
surf = pygame.surfarray.make_surface(canvas_for_visited)

clock = pygame.time.Clock()
done = False
while not done:
    for event in pygame.event.get():   
        if event.type == pygame.QUIT:  
            done = True   
 
    gameDisplay.fill(black)
    for i in range(len(All_list)):
            x = All_list[i].node_loc[1]
            y1 = All_list[i].node_loc[0]
            y = abs(249-y1)
            pygame.draw.rect(gameDisplay, white, [x,y,1,1])
            pygame.display.flip()
    
    for i in range(len(x_a)):
        pygame.time.wait(5)
        x = y_a[i]
        y2 = x_a[i]
        y = abs(249-y2)
        pygame.draw.rect(gameDisplay, (255,0,0), [x,y,1,1])
        pygame.display.flip()
        pygame.time.wait(5)
    done = True
pygame.quit()

#visited path
for i in range(len(All_list)):
    x = All_list[i].node_loc[1]
    y1 = All_list[i].node_loc[0]
    canvas_for_backtrack[(249-y1,x)]=[255,0,0]
tracked = cv2.resize(canvas_for_backtrack,(1200,750))
cv2.imshow('visited nodes',tracked)
cv2.waitKey(0)
cv2.destroyAllWindows()


#backtracked path
for i in range(len(x_a)):
    x = y_a[i]
    y2 = x_a[i]
    # y = abs(249-y2)
    canvas_for_backtrack[(249-y2,x)]=[0,255,0]
#showing the final backtracked path
tracked = cv2.resize(canvas_for_backtrack,(1200,750))
cv2.imshow('tracked path',tracked)
cv2.waitKey(0)
cv2.destroyAllWindows()